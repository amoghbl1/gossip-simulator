import com.distributed.systems.GossipProtos.Gossip;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.FileReader;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.Random;

public class GossipNode extends UnicastRemoteObject implements GossipInterface {
    
    static int GOSSIP_NODE_GENERATE_AND_LISTEN = 0;
    static int GOSSIP_NODE_JUST_LISTEN = 1;
    static int CLOCK_JUST_INITIALIZED = -459;
    static int LOCAL_CLOCK_INITIALIZE_VALUE = 0;
    static String DONT_SEND="DontNeedToSend";

    private int gossipNodeID;
    private int gossipNodeLocalClock;
    private int gossipNetworkSize;
    private int gossipNodeType;
    private String gossipNodeInputFile;
    private String gossipLatestMessage;
    private int previousRandomGossip;

    // THIS IS THE CLOCK, A HYBRID OF ProcessID:ProcessClock 
    // Look at the acceptMessage function to see how our clock comparision is done.
    private int gossipClockID;
    private int gossipClockCount;
    
    public GossipNode(int nodeId, int networkSize, int nodeType) throws RemoteException {
        this.gossipNodeID = nodeId;
        this.gossipNetworkSize = networkSize;
        this.gossipNodeType = nodeType;
        this.gossipClockID = CLOCK_JUST_INITIALIZED;
        this.gossipClockCount = CLOCK_JUST_INITIALIZED;
        this.gossipNodeLocalClock = LOCAL_CLOCK_INITIALIZE_VALUE;
        this.previousRandomGossip = -1;
    }

    public void setInputFile(String fileName) { this.gossipNodeInputFile = fileName; }

    private void updateLocalClock(int clockID, int clockCount) {
        this.gossipClockID = clockID;
        this.gossipClockCount = clockCount;
    }

    private String getRandomNode() {
        // Helper to pick random nodes, defined here in order to make it easier to extend this code to do more stuff.
        Random randomGenerator = new Random();
        int randomNumber = randomGenerator.nextInt(this.gossipNetworkSize);
        // Making sure we don't pick ourselves
        // Making sure we don't send the message back to the one that started the gossip, it would get rejected, but this is a waste.
        // Make sure we don't pick what we had just picked, this causes some kind of a socket error if 2
        // threads end up calling the same gossipNode.
        if(this.gossipNetworkSize > 3) {
            if(randomNumber == this.gossipNodeID || randomNumber == this.gossipClockID || randomNumber == this.previousRandomGossip)
                return this.getRandomNode();
        }
        else if(this.gossipNetworkSize <= 3) {
            if(this.gossipNodeID != this.gossipClockID)
                return this.DONT_SEND;
            if(randomNumber == this.gossipNodeID || randomNumber == this.previousRandomGossip)
                return this.getRandomNode();
        }
        // Making sure we don't send the message back to the one that started the gossip, it would get rejected, but this is a waste.
        // Make sure we don't pick what we had just picked, this causes some kind of a socket error if 2 
        // threads end up calling the same gossipNode.
        this.previousRandomGossip = randomNumber;
        return "Gossip" + randomNumber;
    }

    private void gossipPrint(String message) {
        System.out.println("Gossip node: "
                + this.gossipNodeID 
                + " of " + this.gossipNetworkSize + " " 
                + message);
    }

    private Boolean acceptMessage(int newNodeClockID, int newNodeClockCount){
        // This happens only when we have never seen any messages, or processed any either.
        if(this.gossipClockID == CLOCK_JUST_INITIALIZED || this.gossipClockCount == CLOCK_JUST_INITIALIZED)
            return true;
        // We only need to worry about the case when out Node ID is the same. If not, we don't have to.
        if(newNodeClockID == this.gossipClockID && newNodeClockCount > this.gossipClockCount)
            return true;
        // By default, we accept a message, that is, if they were generated by 2 different processes, we can't say, so we accept.
        else if(newNodeClockID != this.gossipClockID)
            return true;
        return false;
    }
    
    private synchronized void processGossip(String gossipLine) {
        // Added the clock, we assume that the caller of this function handles the updating.
        // Further processing is done by the thread. (Pick and send part).
        new GossipProcessThread(gossipLine, this.gossipClockID, this.gossipClockCount, this).start();
    }
    
    public void hearGossip(byte[] gossipProtobuf) {
        // This is the interface through which other nodes of our network communicate with this one.
        Gossip gossip;
        try {
        gossip = Gossip.parseFrom(gossipProtobuf);
        } catch (Exception e) {
            System.out.println("Gossip parse exception: " + e.getMessage());
            e.printStackTrace();
            return;
        }
        
        String gossipMessage = gossip.getGossipMessage();
        int gossipSourceID = gossip.getGossipSourceID();
        int gossipSourceClock = gossip.getGossipSourceClock();

        // Compare the local clock with the clock of the message.
        // If new clock, process it. Else Reject.
        if( acceptMessage(gossipSourceID, gossipSourceClock) ) {
            updateLocalClock(gossipSourceID, gossipSourceClock);
            processGossip(gossipMessage);
            gossipPrint("Accept message: " + gossipMessage);
        }
        else {
            // We rejected that message.
            gossipPrint("Rejected message: " + gossipMessage);
        }
    }


    public static void main(String args[]) {
        if(args.length <= 1) {
            System.out.println("Error: Please pass correct arguments");
            return;
        }
        int myType;
        // Parse all the stuff that the CLI call gave us.
        // USAGE:
        // ./MyServer <id> <numProcesses> [-i <inputFile>]
        myType = (args.length >= 4) ? GOSSIP_NODE_GENERATE_AND_LISTEN : GOSSIP_NODE_JUST_LISTEN;

        // Initialize myself, talk to the rmiregistry
        try {
            GossipNode node = new GossipNode(
                    Integer.parseInt(args[0]), 
                    Integer.parseInt(args[1]), 
                    myType);
            
            if(myType == GOSSIP_NODE_GENERATE_AND_LISTEN) { 
                node.setInputFile(args[3]);
                // Need to start my input looper thread here.
                new InputLooperThread(args[3], node).start(); // I also send the thread myself, so that it may call process gossip on this class.
            }
            
            // Bind this object instance to the name "HelloServer"
            Naming.rebind("Gossip" + args[0], node);
        } catch (Exception e) {
            System.out.println("Err: " + e.getMessage());
            e.printStackTrace();
        }
    }

    static class InputLooperThread extends Thread {
        GossipNode callerNode;
        BufferedReader fileReader;
        
        int GOSSIP_READ_INPUT_TIME = 5000;
        public InputLooperThread(String file, Object obj) { 
            try {
                this.fileReader = new BufferedReader(new FileReader(file));
            } catch (Exception e) {
                System.out.println("Bad file?? " + e.getMessage());
                e.printStackTrace();
            }
            this.callerNode = (GossipNode)obj;
        }
        public void run() {
            String inputLine;
            while(true) {
                try {
                    if((inputLine = this.fileReader.readLine()) == null)
                        return;
                } catch (Exception e) {
                    System.out.println("Input file read problems?? " + e.getMessage());
                    e.printStackTrace();
                    return;
                }
                // Calling process on a new line, can never be wrong.
                // We have 2 case:
                // 1: When nodeId is this node itself, in which case, we will always be reading later lines, so it's not possible that a message isn't supposed to be processed.
                // 2: When nodeId is another node, in which case, we have said that the new message is accepted, and this will go by our convention.
                // Just remember to update the clock.
                this.callerNode.gossipNodeLocalClock += 1;
                this.callerNode.updateLocalClock(this.callerNode.gossipNodeID, this.callerNode.gossipNodeLocalClock);
                this.callerNode.processGossip(inputLine);
                try {
                    Thread.sleep(GOSSIP_READ_INPUT_TIME);
                } catch (Exception e) {
                    System.out.println("Thread Interrupted?? " + e.getMessage());
                    e.printStackTrace();
                }   
            }        
        }            
    }

    static class GossipProcessThread extends Thread {
        static int GOSSIP_PROCESS_TIME = 1000; // Defaulting to 1 second processing.
        private String gossip;
        private int gossipID;
        private int gossipClock;
        private GossipNode callerNode;
        
        // Number of nodes to forward message to.
        private int GOSSIP_FORWARD_VALUE = 2;

        public GossipProcessThread(String gossipMessage, int gossipNodeID, int gossipNodeClock, Object callerObj) {
            this.gossip = gossipMessage;
            this.gossipID = gossipNodeID;
            this.gossipClock = gossipNodeClock;
            this.callerNode = (GossipNode) callerObj;
        }
        public void run() {
            try {
                Thread.sleep(GOSSIP_PROCESS_TIME);
            } catch (Exception e) {
                System.out.println("Thread Interrupted?? " + e.getMessage());
                e.printStackTrace();
            }
            // Do the processing
            // Pick 2 random nodes that aren't the caller node.
            int i;
            String nodeToSend;
            
            Gossip.Builder gossipBuilder = Gossip.newBuilder();
            gossipBuilder.setGossipMessage(this.gossip);
            gossipBuilder.setGossipSourceID(this.gossipID);
            gossipBuilder.setGossipSourceClock(this.gossipClock);
            byte[] gossipEncoded = gossipBuilder.build().toByteArray();
            for(i=0; i < GOSSIP_FORWARD_VALUE; i++) {
                nodeToSend = this.callerNode.getRandomNode();
                if(nodeToSend.equals(this.callerNode.DONT_SEND)) {
                    System.out.println("WE SHOULDN'T SEND!!");
                    continue;
                }
                // call hearGossip on them.
                try {
                GossipInterface gossipNodeToSendTo = (GossipInterface) Naming.lookup("//" +
                        "localhost/" +
                        nodeToSend);
                gossipNodeToSendTo.hearGossip(gossipEncoded);
                } catch (Exception e) {
                    System.out.println("Hear gossip call problem?? " + e.getMessage());
                    e.printStackTrace();
                }
            }
        }
    }
}
